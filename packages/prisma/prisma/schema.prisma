generator client {
  provider      = "prisma-client-js"
  output        = "../generated/prisma"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
}

generator zod {
  provider = "zod-prisma-types"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id               String           @id
  clerkId          String           @unique
  email            String           @unique
  username         String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @default(now()) @updatedAt
  organizationId   String?
  role             UserRole         @default(MEMBER)
  paymentHistories PaymentHistory[]
  subscription     Subscription?
  assignedTickets  Ticket[]         @relation("AssignedAgent")
  ticketUpdates    TicketUpdate[]
  organization     Organization?    @relation(fields: [organizationId], references: [id])
}

model Subscription {
  id                      String                    @id
  userId                  String                    @unique
  planId                  String
  status                  SubscriptionStatus
  lemonSqueezyId          String                    @unique
  lemonSubscriptionItemId String?
  lemonCustomerId         String
  lemonOrderId            String                    @unique
  lemonProductId          String
  lemonVariantId          String
  renewsAt                DateTime?                 @db.Timestamptz(3)
  endsAt                  DateTime?                 @db.Timestamptz(3)
  paymentMethod           SubscriptionPaymentMethod
  cardBrand               String?
  cardLast4               String?
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @default(now()) @updatedAt
  plan                    Plan                      @relation(fields: [planId], references: [id])
  user                    User                      @relation(fields: [userId], references: [id])
}

model Plan {
  id                    String         @id
  title                 String
  name                  String
  description           String?
  content               Json?
  available             Boolean        @default(true)
  price                 Decimal        @db.Decimal(12, 2)
  lemonSqueezyProductId String
  lemonSqueezyVariantId String
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @default(now()) @updatedAt
  subscriptions         Subscription[]
}

model WebhookEvent {
  id          String   @id
  eventId     String   @unique
  eventName   String
  resourceId  String
  processedAt DateTime @default(now())
  payload     Json
  createdAt   DateTime @default(now())

  @@index([eventName, resourceId])
  @@index([processedAt])
}

model PaymentHistory {
  id                String        @id
  userId            String
  invoiceId         String        @unique
  subscriptionId    String
  customerId        String
  userEmail         String
  billingReason     String
  status            PaymentStatus
  statusFormatted   String
  currency          String
  currencyRate      String
  subtotal          Int
  discountTotal     Int
  tax               Int
  taxInclusive      Boolean
  total             Int
  refundedAmount    Int           @default(0)
  subtotalUsd       Int
  discountTotalUsd  Int
  taxUsd            Int
  totalUsd          Int
  refundedAmountUsd Int           @default(0)
  cardBrand         String?
  cardLastFour      String?
  invoiceUrl        String?
  testMode          Boolean       @default(false)
  refundedAt        DateTime?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([subscriptionId])
  @@index([status])
  @@index([createdAt])
}

model Organization {
  id          String   @id @default(cuid())
  clerkOrgId  String   @unique
  name        String
  slug        String   @unique
  description String?
  settings    Json?    @default("{}")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @default(now()) @updatedAt
  tickets     Ticket[]
  users       User[]
}

model Ticket {
  id                    String              @id @default(cuid())
  organizationId        String
  citizenName           String
  citizenPhone          String?
  citizenEmail          String?
  citizenAddress        String?
  content               String
  category              String?
  status                TicketStatus        @default(NEW)
  priority              TicketPriority      @default(NORMAL)
  assignedToId          String?
  publicToken           String              @unique @default(uuid())
  slaDueAt              DateTime?
  repliedAt             DateTime?
  closedAt              DateTime?
  aiSuggestedAssigneeId String?
  aiConfidenceScore     Float?
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @default(now()) @updatedAt
  aiDraftAnswer         String?
  aiErrorMessage        String?
  aiNeedsManualReview   Boolean             @default(false)
  aiSummary             String?
  sentiment             Sentiment?
  
  // Community fields
  isPublic              Boolean             @default(true)
  publicExcerpt         String?             @db.Text
  source                String              @default("internal")
  nickname              String?
  
  survey                SatisfactionSurvey?
  assignedTo            User?               @relation("AssignedAgent", fields: [assignedToId], references: [id])
  organization          Organization        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  updates               TicketUpdate[]
  likes                 CommunityLike[]
  comments              CommunityComment[]

  @@index([organizationId, status])
  @@index([assignedToId, status])
  @@index([publicToken])
  @@index([createdAt])
  @@index([priority, status])
  @@index([isPublic, createdAt])
  @@index([source])
}

model TicketUpdate {
  id         String           @id @default(cuid())
  ticketId   String
  userId     String?
  updateType TicketUpdateType
  content    Json
  replyText  String?
  createdAt  DateTime         @default(now())
  ticket     Ticket           @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user       User?            @relation(fields: [userId], references: [id])

  @@index([ticketId, createdAt])
  @@index([updateType])
}

model SatisfactionSurvey {
  id                   String    @id @default(cuid())
  ticketId             String    @unique
  rating               Int       @db.SmallInt // 1-5 scale validated at application level
  feedback             String?   @db.Text
  responderFingerprint String?   // For duplicate prevention (hashed IP + user agent)
  channelSentAt        DateTime? // When the satisfaction request was sent
  sentAt               DateTime  @default(now())
  submittedAt          DateTime?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @default(now()) @updatedAt
  ticket               Ticket    @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([rating])
  @@index([submittedAt])
  @@index([channelSentAt])
}

model CommunityLike {
  id          String    @id @default(cuid())
  ticketId    String
  ticket      Ticket    @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  ipHash      String    // Hashed IP address for duplicate prevention
  userAgent   String?   // Optional user agent for additional fingerprinting
  createdAt   DateTime  @default(now())

  @@unique([ticketId, ipHash]) // Prevent duplicate likes from same IP
  @@index([ticketId])
  @@index([createdAt])
}

model CommunityComment {
  id          String    @id @default(cuid())
  ticketId    String
  ticket      Ticket    @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  nickname    String    @default("익명")
  content     String    @db.Text
  ipHash      String    // For rate limiting and moderation
  isHidden    Boolean   @default(false) // For moderation
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @default(now()) @updatedAt

  @@index([ticketId, createdAt])
  @@index([isHidden])
}

model NotificationQueue {
  id          String               @id @default(cuid())
  ticketId    String
  type        NotificationType
  channel     NotificationChannel
  recipient   String               // Phone number or email
  payload     Json
  status      NotificationStatus   @default(PENDING)
  attemptCount Int                 @default(0)
  lastAttemptAt DateTime?
  scheduledFor DateTime            @default(now())
  sentAt      DateTime?
  error       String?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @default(now()) @updatedAt

  @@index([status, scheduledFor])
  @@index([ticketId])
  @@unique([ticketId, type]) // Prevent duplicate notifications
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  UNPAID
  PAST_DUE
}

enum UserRole {
  ADMIN
  MEMBER
  VIEWER
}

enum TicketStatus {
  NEW
  CLASSIFIED
  IN_PROGRESS
  REPLIED
  CLOSED
}

enum TicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

enum TicketUpdateType {
  STATUS_CHANGE
  COMMENT
  REPLY_SENT
  ASSIGNMENT_CHANGE
  PRIORITY_CHANGE
  CATEGORY_CHANGE
}

enum Sentiment {
  POSITIVE
  NEUTRAL
  NEGATIVE
}

enum SubscriptionPaymentMethod {
  CARD
  BANK_TRANSFER
  PAYPAL
}

enum PaymentStatus {
  SUCCESS
  FAILED
  REFUNDED
  PENDING
}

enum NotificationType {
  RECEIPT_CONFIRMATION
  STATUS_UPDATE
  REPLY_SENT
  SATISFACTION_REQUEST
}

enum NotificationChannel {
  SMS
  EMAIL
  KAKAO
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
}
